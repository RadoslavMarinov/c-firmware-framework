



 ************************************************************* PAGE 1 *************************************************************
 [ ] Inline функции няма да се използват. Където е необходимо може да се имплементира с макрос @started(16-03-29 14:28) @high
 [ ] Имената на елементите (полетата) на структурите които описват картата на регистрите (register map) започват с малка буква. @started(16-03-29 14:29)  
 [ ] Папката 'efm32' съдържа кпмпоненти. Компонентите представляват физическите периферии на серията MCUs. Компонентът 'mcu' например агрегира няколко собствени класа(1). Всеки от тези класове представлява един или няколко регистъра които споделят една функционалност. @started(16-04-01 11:57)
     [ ] Тези класове логически са разделени на пропъртита. Всяко пропърти представлява битово поле вътре в регистъра. Свойствата на това поле се определят ot документацията на контролера (register description). @started(16-04-01 11:57)
     .
 [ ] Статични локални променливи да НЕ се използват! @started(16-06-01 17:08)  @high  

 [ ] #define class_name_getSomething()   ( right side expansion )
      [ ]  Когато използваме ^такъв^ тип макрос, който връща стойност (независимо дали е стойността на обект или израз) "right side expansion" дясната страна на макроса трябва да бъде оградена в скоби за да се избегне operator precedence конфликт. Въпреки, че в случай че макросът връща literal value не виждам

EFM32:
 [ ] Литералите в драйверните компоненти (например gpio) да се стреми да се  представят съобразно документацията. 
    > Например:  PB_MODEH_getPropertyValue(0b0100, 4). Тук първият аргумент е представен бинарно, понеже в документацията изборимите стройности са представени бинарно също: EF32WGReferenceManual:757:Table 32.1.


 
************************************************************* PAGE 2 *************************************************************

 

 (1) Собствен клас е класа който се композира от компонента и се намира в същата директория в която се намират и компонентните файлове(1').
 (2) Стойността на пропъртито е константна. Тя се определя чрез макрос и представлява една атомична стъпка на изменение на пропъртито. Тя се определя от документацията (reference manual - register description). 
 (3) Стойността на обекта на пропъртито, е маскираната стойност, която се извлича директно то регистъра/регистрите, Маската е маската на пропъртито.




 (1') Компонентните файлове са четири на брой: component-name-derivative.h, component-name-primary.h, component-name.c, component-name-configuration.h. Файловете  component-name-derivative.h, component-name.c съставяват компонентния клас, а component-name-configuration.h служи за конфигурация на компонента и  предоставя връзките между агрегураните от него класове.

＿＿＿＿


************************************************************* PAGE 3 *************************************************************
＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿
Archive:
 [-] Когато пропъртито е еднобитово (заема 1 бит от регистъра), към името на меотда който връща [стойността на пропъртитощ(2) на пропъртито се конкатенира 'Value'. Това се прави с цел да няма конфликт между името на  метода който връща стойноста и метода който връща [стойността на обекта на пропъртито](3). Например: property_name_getPropertynameValue()-връща стойноста на пропъртито   VS  y_name_getPropertyname()-връща стойността на обекта на пропертито. @critical @cancelled (16-05-04 17:01)
 [-] Идентификатор за стоиност на one-bit-property(W1) ще съставлява object_getPropertynameAssert() @started(16-04-08 10:07) @high @cancelled (16-04-13 10:40) @wasted(5 days, 0:33) @project(EFM32 / Инерфейси / Идентификатори)
 [-] Всеки регистър(член на структура) от структурата (например: cmu_RegisterMap) на компонент от папката 'EFM32' ще се отделя в отделен файл. Този файл ще представлява ординари клас, съответно ще наследява структурата на ординари клас. Името на файла ще съставлява името на класа със съответното разширение (.c|.h).  @started(16-03-31 16:45) @cancelled (16-04-13 09:46) @wasted(12 days, 17:01)
 [-] Bitfield от изброим тип чийто опции не са изброени в документацията. Пример:EF32WGReferenceManual:767:32.5.6 @cancelled (16-04-08 10:08) @project(EFM32)
 [-] Опциите ще се записват като Bit1, Bit2,.....Bitn. register_name_operationBitfieldnameOptions() @started(16-04-05 16:45) @cancelled (16-04-08 10:08) @wasted(2 days, 17:23) @project(EFM32)
